# 计算机操作系统

## 程序

### 1. 程序和进程区分

程序：打开的qq，是一个静态，

进程是一个动态，进程是程序依次执行的xxxx

### 2. 程序的顺序执行

程序的顺序执行是指若干程序或程序段之间必须严格按照某种==先后次序依次执行==

**特征**：

- 顺序性
- 封闭性：程序在执行时独占系统的全部资源
- 可再现性：多次运行得到同样结果

### 3. 程序的并发执行

程序的并发执行指两个或两个以上的程序或程序段可在==同一时间间隔内同时执行==

特征：

- 间断性：==由于资源共享和相互合作==，并发执行的程序间形成了相互制约关系，导致程序运行过程中出现“执行-暂停-执行”

- 失去封闭性：共享资源，==程序本身的执行环境要受到外界程序的影响==

- 不可再现性

  

## 进程（process）

### 1. 概念

程序并发执行时产生的不可再现性，决定了通常的程序不能参与并发执行，为了使程序能够并发执行，需要对并发执行程序加以描述和控制，引入进程概念，==实现操作系统的并发性和共享性（最基本的两个特征）==。为了使参与并发程序可以独立运行（不与他人共享资源）配置进程控制块（PCB）

PCB、程序段与相关数据段三个部分构成了一个进程尸体，简称进程（==PCB是进程存在的唯一标志==）

PCB内包含的数据结构内容主要有：进程标志信息，进程控制信息，进程资源信息，CPU现场信息

- 进程是程序执行一次执行的过程，是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的独立单位
- ==进程是操作系统资源分配和调度的基本单位。==
   当你运行一个程序（如 Python 脚本），操作系统会为它创建一个进程，分配独立的内存空间、文件句柄、CPU 时间片等资源。
- 每个进程都有独立的地址空间，不同进程之间**默认不共享内存**。
- 一个进程可以包含多个线程。

### 2. 特征：

- 动态性
- 并发性：创建进程后，才可实现进程开发
- 独立性
- 异步性：进程可按各自独立的，不可预知的速度向前推荐，虽然进程具有异步性，但操作系统必须配置相应的同步机制确保进程并发执行的结果可再现

### 3.进程的状态与转换

三种状态

- 运行态：进程在处理机上运行
- 就绪态：获得了除处理及外的一切所需资源（只缺少处理机），一旦得到处理机，便可立即运行
- 阻塞态：也成等待态，正在执行的进程因某种事件（等待io请求？）而无法继续执行，只有等相应事件完成后，才能去竞争cpu

![进程状态转换](/Users/wangjingxin/knowlege_library/basecs/images/进程状态转换.jpeg)

### 4.进程控制和通信

#### 4.1进程控制

进程的控制主要是说创建新进程，终止进程以及负责进程运行过程中的状态转换等，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许终端

*对所有进程实施有效管理*

进程的创建：允许一个进程创建另一个进程

进程的终止：引起进程终止的事件 有正常结束；异常结束；外界干预

进程的阻塞和唤醒：正常执行的进程，由于所希望的事件没有发生（资源请求失败，等待上一部操作），由系统自动执行阻塞原语（block）是自己从运行态到阻塞态；阻塞态得到期望事件，系统将自动执行唤醒原语（wakeup）

#### 4.2进程通讯

进程之间的信息交换，各个进程之间的内存空间相互独立，为了安全，进程之间无法互相访问对方的内存地址，所以需要通讯

通讯分为：低级通讯-PV操作；高级通讯（指以较高的效率传输大量数据的通信方式）-共享存储；消息传递；管道通信

- 共享存储；进程通信通过对共享空间进行读/写操作实现信息交换，共享某些数据结构或者共享存储区

  > 读写操作需要使用同步互斥工具

- 消息传递：进程间的数据交换以消息为单位，通过发送和接收；有两种消息传递方式：直接通信方式和间接通信方式

- 管道通信；用pipe文件连接两个进程

### 3. Python 中的实现

Python 提供 `multiprocessing` 模块，底层通过 `fork`（Unix）或 `spawn`（Windows）创建新进程。

- **好处**：能真正利用多核 CPU（绕过 GIL）。
- **代价**：数据需序列化传输（pickle），频繁通信效率低。

### 补充

#### python GIL锁



## 线程（thread）

### 1. 概念

引入进程的目的是为了更好的使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的的是为了减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

> 减少系统付出的时空开销：

- 调度：进程是拥有资源的基本单位，线程是调度和分派的基本单位。线程是 CPU 调度的最小单位。
- 资源所属权：进程是拥有资源的基本单位，线程不拥有系统资源，因此，多个线程共享同一进程的内存空间与资源。
- 并发性：在同一进程中可并发执行多个线程任务（逻辑上同时）。
- 系统开销
- 地址空间和其他资源：进程的地址空间之间互相独立，同一进程的歌线程之间共享进程的资源，某进程内的线程对其他进程不可见
- 通信方面：进程间需要通过同步互斥手段保证数据一致性；线程之间可以直接读写来完成通信

### 3. Python 中的实现

- 使用 `threading` 模块 或 `concurrent.futures.ThreadPoolExecutor`。
- **GIL（全局解释器锁）** 限制：Python 同一时刻只允许一个线程执行字节码。
   → 多线程在 CPU 密集任务中**无法**并行加速，但 IO 密集型任务可显著提速。



## 协程（协作式并发 / Coroutine / asyncio）

### 1. 概念

- **协程（Coroutine）是用户态的轻量级线程。**
- 与操作系统线程不同，协程切换由程序自行控制（非抢占式），在 `await` 处主动让出控制权。
- 所谓“协作式并发”：任务之间靠**主动让出执行权**实现并发，不依赖系统调度。

### 2. 特点

| 特点       | 描述                                                 |
| ---------- | ---------------------------------------------------- |
| 单线程运行 | 所有协程在一个线程内调度。                           |
| 切换快速   | 不涉及内核态/用户态切换，性能极高。                  |
| 无锁模型   | 因为单线程运行，避免大多数锁竞争问题。               |
| 适合场景   | **高并发 IO**：网络爬虫、异步 API 调用、聊天服务器。 |

### 3. Python 中的实现

### 1. 概念

- **协程（Coroutine）是用户态的轻量级线程。**
- 与操作系统线程不同，协程切换由程序自行控制（非抢占式），在 `await` 处主动让出控制权。
- 所谓“协作式并发”：任务之间靠**主动让出执行权**实现并发，不依赖系统调度。

### 2. 特点

| 特点       | 描述                                                 |
| ---------- | ---------------------------------------------------- |
| 单线程运行 | 所有协程在一个线程内调度。                           |
| 切换快速   | 不涉及内核态/用户态切换，性能极高。                  |
| 无锁模型   | 因为单线程运行，避免大多数锁竞争问题。               |
| 适合场景   | **高并发 IO**：网络爬虫、异步 API 调用、聊天服务器。 |

### 3. Python 中的实现

- `asyncio` 模块是 Python 原生的异步事件循环库。

- 关键语法：

  ```
  async def func():
      await some_io()
  ```

- 可配合 `await asyncio.gather(...)` 并发执行大量任务。

- 若遇 CPU 密集任务，可用 `run_in_executor()` 委托到线程池或进程池。

## 什么时候需要进程，线程，携程

## 🧠 一句话总结对比

| 场景类型                       | 推荐机制                                       | 原因                     |
| ------------------------------ | ---------------------------------------------- | ------------------------ |
| **CPU 密集型**（要算得快）     | ✅ **进程（multiprocessing）**                  | 真正多核并行，避开 GIL。 |
| **IO 密集型**（要等得快）      | ✅ **线程（threading）** 或 **协程（asyncio）** | 多任务等待时可并发执行。 |
| **高并发网络任务**（要省资源） | ✅ **协程（asyncio）**                          | 最轻量、切换成本极低。   |



# 计算机网络